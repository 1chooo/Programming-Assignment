# -*- coding: utf-8 -*-
"""機器學習降雨預測專題.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-EH2SZtS_Zc55DUc7PGL7xN58DahNL94

# **梅雨還是沒雨？**

安裝套件
"""

# !pip install pandas
# !pip install numpy
# !pip install matplotlib
# !pip install seaborn
# !pip install joblib
# !pip install sklearn
# !pip install flask

"""Import 套件"""

# -*- coding: utf-8 -*-

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import os
import glob
from google.colab import drive

"""資料合併"""

path_domestic = os.path.abspath(os.getcwd()) + '/data'
root = "/content/drive/MyDrive/1102/AI Machine learning/data"
data = glob.glob(os.path.join(root, "*.csv"))


df_1 = pd.concat((pd.read_csv(f) for f in data))

df_1.to_csv('./1_f.csv',encoding="utf_8_sig",index=False)

from google.colab import drive
drive.mount('/content/drive')

"""利用已取得的資料，讀取並存入讀取並存入data frame"""

df = pd.read_csv("./1_f.csv")

"""Explore the data we have."""

df.info()
df.head()
df.describe().T

"""由上看出有些資料我們並不需要，因此我們加以整理，因此移除我們覺得不需要的變數"""

df.drop(['ObsTime', 'SeaPres', 'StnPresMaxTime', 'StnPresMinTime'], axis = 1, inplace = True)
df.drop(['T Max Time', 'T Min Time', 'Td dew point'], axis = 1, inplace = True)
df.drop(['RHMinTime', 'WGustTime'], axis = 1, inplace = True)
df.drop(['PrecpHour', 'PrecpMax10', 'PrecpMax10Time', 'PrecpMax60', 'PrecpMax60Time'], axis = 1, inplace = True)
df.drop(['SunShine', 'SunShineRate', 'GloblRad', 'VisbMean'], axis = 1, inplace = True)
df.drop(['EvapA', 'UVI Max', 'UVI Max Time', 'Cloud Amount'], axis = 1, inplace = True)

"""再觀察一下我們的資料"""

df.info()

"""首先我們看到幾乎所有資料的型態都為object並且都沒有缺失值，因此我們要對此處理，結果發現轉換不了，有些原始資料的缺失值會以「...」的方式補齊，所以我們要先把「...」先替代掉，再把data type轉換成轉換成float。"""

df.drop(['ObsTime'], axis = 1, inplace = True)

df = df.replace('...','-999.0')
df = df.replace('/','-999.0')
df = pd.DataFrame(df, dtype = np.float)

"""再觀察一下我們的資料"""

df.info()

"""我們先處理降雨量，因為有降水及代表有下雨，所以只要大於大於0就轉換為1，反之轉換為0。"""

for k in range(854):
    if df.iloc[k,12] > 0.0:
        df.iloc[k,12] = 1
    else:
        df.iloc[k,12] = 0

"""有些資料我們打算用平均值來填補，並取到小數點後第一位"""

count0, count1, count2, count3, count4, count5, count8 , count10 = 0, 0, 0, 0 ,0, 0, 0, 0
stnprestotal , stnpresmaxtotal , stnpresmintotal, WStotal , WSGusttotal, Ttotal , Tmaxtotal , Tmintotal = 0 , 0 , 0, 0 , 0, 0 , 0 , 0

for k in range(0,853):
    if (df.iloc[k,0] != -999.0):
        stnpres = float(df.iloc[k,0])
        count0 += 1
        stnprestotal += stnpres
    if (df.iloc[k,1] != -999.0):
        stnpresmax = float(df.iloc[k,1])
        count1 += 1
        stnpresmaxtotal += stnpresmax
    if (df.iloc[k,2] != -999.0):
        stnpresmin = float(df.iloc[k,2])
        count2 += 1
        stnpresmintotal += stnpresmin
    if (df.iloc[k,3] != -999.0):
        T = float(df.iloc[k,3])
        count3 += 1
        Ttotal += T
    if (df.iloc[k,4] != -999.0):
        Tmax = float(df.iloc[k,4])
        count4 += 1
        Tmaxtotal += Tmax
    if (df.iloc[k,5] != -999.0):
        Tmin = float(df.iloc[k,5])
        count5 += 1
        Tmintotal += Tmin
    if (df.iloc[k,8] != -999.0):
        WS = float(df.iloc[k,8])
        count8 += 1
        WStotal += WS
    if (df.iloc[k,10] != -999.0):
        WSGust = float(df.iloc[k,10])
        count10 += 1
        WSGusttotal += WSGust

ave0 = round(stnprestotal / count0 , 1)
ave1 = round(stnpresmaxtotal / count1 , 1)
ave2 = round(stnpresmintotal / count2 , 1)
ave3 = round(Ttotal / count3 , 1)
ave4 = round(Tmaxtotal / count4 , 1)
ave5 = round(Tmintotal / count5 , 1)
ave8 = round(WStotal / count8 , 1)
ave10 = round(WSGusttotal / count10 , 1)

for c in range(854):
    if df.iloc[c,0] == -999.0:
        df.iloc[c,0] = ave0
    if df.iloc[c,1] == -999.0:
        df.iloc[c,1] = ave1
    if df.iloc[c,2] == -999.0:
        df.iloc[c,2] = ave2
    if df.iloc[c,3] == -999.0:
        df.iloc[c,3] = ave3
    if df.iloc[c,4] == -999.0:
        df.iloc[c,4] = ave4
    if df.iloc[c,5] == -999.0:
        df.iloc[c,5] = ave5
    if df.iloc[c,8] == -999.0:
        df.iloc[c,8] = ave8
    if df.iloc[c,10] == -999.0:
        df.iloc[c,10] = ave10

"""剩下的資料我們以眾數的方式來填補缺失值"""

for i in range(854):
    if df.iloc[i,6] == -999.0:
            df.iloc[i,6] = df['RH'].value_counts().idxmax()

for i in range(854):
    if df.iloc[i,7] == -999.0:
            df.iloc[i,7] = df['RHMin'].value_counts().idxmax()           

for i in range(854):
    if df.iloc[i,9] == -999.0:
            df.iloc[i,9] = df['WD'].value_counts().idxmax()

for i in range(854):
    if df.iloc[i,11] == -999.0:
            df.iloc[i,11] = df['WDGust'].value_counts().idxmax()

"""接著我們看看，每個各別資料對雨量的關係圖"""

x1 = df['StnPres']
x2 = df['StnPresMax']
x3 = df['StnPresMin']
x4 = df['T Max']
x5 = df['T Min']
x6 = df['Temperature']
x7 = df['RH']
x8 = df['RHMin']
x9 = df['WS']
x10 = df['WD']
x11 = df['WSGust']
x12 = df['WDGust']
y = df['Precp']

plt.figure(figsize=(16, 12))

plt.subplot(3, 4, 1)
plt.scatter(x1,y)
plt.subplot(3, 4, 2)
plt.scatter(x2,y)
plt.subplot(3, 4, 3)
plt.scatter(x3,y)
plt.subplot(3, 4, 4)
plt.scatter(x4,y)
plt.subplot(3, 4, 5)
plt.scatter(x5,y)
plt.subplot(3, 4, 6)
plt.scatter(x6,y)
plt.subplot(3, 4, 7)
plt.scatter(x7,y)
plt.subplot(3, 4, 8)
plt.scatter(x8,y)
plt.subplot(3, 4, 9)
plt.scatter(x9,y)
plt.subplot(3, 4, 10)
plt.scatter(x10,y)
plt.subplot(3, 4, 11)
plt.scatter(x11,y)
plt.subplot(3, 4, 12)
plt.scatter(x12,y)

plt.show()

"""接著我們看看，每個各別變數之間相關係數"""

df.corr()

"""我們接著再把所有資料都餵給模型，來觀察模型辨識程度"""

X = df.drop(['Precp'], axis=1)
y = df['Precp']

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score

X_train,X_test, y_train,y_test = train_test_split(X, y, test_size=0.3, random_state=67)
lr = LogisticRegression(max_iter=200)
lr.fit(X_train, y_train)
predictions = lr.predict(X_test)
accuracy_score(y_test, predictions)
recall_score(y_test, predictions)
precision_score(y_test, predictions)

"""經過多次交叉測試後，發現什麼都沒有刪除，分數會最高"""

X = df.drop(['Precp'], axis=1)
y = df['Precp']
X_train,X_test, y_train,y_test = train_test_split(X, y, test_size=0.3, random_state=67)
lr = LogisticRegression(max_iter=200)
lr.fit(X_train, y_train)
predictions = lr.predict(X_test)
accuracy_score(y_test, predictions)
recall_score(y_test, predictions)
precision_score(y_test, predictions)

"""接著我們圖表化看出模型的矩陣關係

"""

pd.DataFrame(confusion_matrix(y_test, predictions), columns = ['Predict not rain','Predict rain'], index=['True not rain', 'True rain'])

"""最後我們測試模型的辨認是否順利，然後有發現到測出來的型態為[1.]、[0.]"""

print(lr.predict([[900, 1000, 850, 23, 27, 18, 34, 12, 1, 23, 2, 45]]))
print(lr.predict([[900, 860, 950 , 26, 31, 20, 70 , 50 , 3 , 20 , 6 , 25 ]]))

"""利用joblib模組將模型匯出"""

import joblib
joblib.dump(lr,'Precipitation_Predict.pkl',compress=3)

